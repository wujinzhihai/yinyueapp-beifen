/**
 * ğŸ“ æ­Œè¯è§£æå·¥å…·
 *
 * åŠŸèƒ½: è§£æLRCæ ¼å¼æ­Œè¯
 * - è§£æLRCæ ¼å¼æ­Œè¯æ–‡æœ¬
 * - è½¬æ¢ä¸ºæ—¶é—´è½´æ•°ç»„
 * - è·å–å½“å‰æ’­æ”¾æ—¶é—´å¯¹åº”çš„æ­Œè¯ç´¢å¼•
 */

// æ­Œè¯è¡Œæ¥å£
export interface LyricLine {
  time: number;
  text: string;
}

// æ­Œè¯è§£æå·¥å…·ç±»
export class LyricParser {
  /**
   * è§£æLRCæ ¼å¼æ­Œè¯
   */
  static parse(lrcText: string): LyricLine[] {
    if (!lrcText) return [];

    const lines = lrcText.split('\n');
    const lyrics: LyricLine[] = [];

    lines.forEach(line => {
      // åŒ¹é…æ—¶é—´æ ‡ç­¾ [00:00.00] æˆ– [00:00.000]
      const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)/);

      if (match) {
        const minutes = parseInt(match[1]);
        const seconds = parseInt(match[2]);
        const milliseconds = parseInt(match[3].padEnd(3, '0'));
        const text = match[4].trim();

        if (text) {
          const time = minutes * 60 + seconds + milliseconds / 1000;
          lyrics.push({ time, text });
        }
      }
    });

    // æŒ‰æ—¶é—´æ’åº
    lyrics.sort((a, b) => a.time - b.time);
    return lyrics;
  }

  /**
   * è·å–å½“å‰æ—¶é—´å¯¹åº”çš„æ­Œè¯ç´¢å¼•
   */
  static getCurrentIndex(lyrics: LyricLine[], currentTime: number): number {
    let activeIndex = -1;

    for (let i = 0; i < lyrics.length; i++) {
      if (lyrics[i].time <= currentTime) {
        activeIndex = i;
      } else {
        break;
      }
    }

    return activeIndex;
  }
}
