import http from '@ohos.net.http';
import { MusicItem } from '../models/MusicModels';

// ğŸ”¥ å®šä¹‰ç¼“å­˜æ•°æ®æ¥å£
interface CacheData {
  data: string;
  timestamp: number;
}

// ğŸ”¥ å®šä¹‰ HTTP è¯·æ±‚é€‰é¡¹æ¥å£
interface HttpRequestOptions {
  method: http.RequestMethod;
  header: Record<string, string>;
  connectTimeout: number;
  readTimeout: number;
}

class MusicApiService {
  private static readonly BASE_URL: string = 'https://music-api.gdstudio.xyz/api.php';
  private static readonly DEFAULT_SOURCE: string = 'netease';

  // ğŸ”¥ é™æµé…ç½®
  private static readonly MAX_REQUESTS: number = 60;
  private static readonly TIME_WINDOW: number = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  private static readonly CACHE_DURATION: number = 10 * 60 * 1000; // 10åˆ†é’Ÿ

  private static requestQueue: number[] = [];
  private static cache: Map<string, CacheData> = new Map();

  /**
   * ğŸ”¥ æ£€æŸ¥å¹¶ç­‰å¾…è¯·æ±‚è®¸å¯
   */
  private static async checkRateLimit(): Promise<void> {
    const now: number = Date.now();

    // ç§»é™¤5åˆ†é’Ÿä¹‹å‰çš„è®°å½•
    MusicApiService.requestQueue = MusicApiService.requestQueue.filter(
      (timestamp: number) => now - timestamp < MusicApiService.TIME_WINDOW
    );

    // å¦‚æœè¾¾åˆ°é™åˆ¶ï¼Œç­‰å¾…
    if (MusicApiService.requestQueue.length >= MusicApiService.MAX_REQUESTS) {
      const oldestRequest: number = MusicApiService.requestQueue[0];
      const waitTime: number = MusicApiService.TIME_WINDOW - (now - oldestRequest);

      console.warn(`[MusicAPI] è¯·æ±‚é¢‘ç‡é™åˆ¶ï¼Œç­‰å¾… ${Math.ceil(waitTime/1000)} ç§’`);
      await MusicApiService.delay(waitTime);

      // é€’å½’æ£€æŸ¥
      return MusicApiService.checkRateLimit();
    }

    // è®°å½•æœ¬æ¬¡è¯·æ±‚
    MusicApiService.requestQueue.push(now);
    console.info(`[MusicAPI] è¯·æ±‚è®¡æ•°: ${MusicApiService.requestQueue.length}/${MusicApiService.MAX_REQUESTS}`);
  }

  /**
   * ğŸ”¥ HTTPè¯·æ±‚å°è£…ï¼ˆå¸¦ç¼“å­˜+é™æµï¼‰
   */
  private static async httpRequest(url: string, options?: HttpRequestOptions): Promise<http.HttpResponse> {
    const now: number = Date.now();

    // ğŸ”¥ æ£€æŸ¥ç¼“å­˜
    if (MusicApiService.cache.has(url)) {
      const cached: CacheData = MusicApiService.cache.get(url)!;
      if (now - cached.timestamp < MusicApiService.CACHE_DURATION) {
        console.info('[MusicAPI] ä½¿ç”¨ç¼“å­˜ï¼Œå‰©ä½™æœ‰æ•ˆæœŸ:',
          Math.ceil((MusicApiService.CACHE_DURATION - (now - cached.timestamp)) / 1000), 'ç§’');

        // ğŸ”¥ è¿”å›æ¨¡æ‹Ÿçš„ HttpResponseï¼ˆè¡¥å…¨æ‰€æœ‰å¿…éœ€å±æ€§ï¼‰
        const mockResponse: http.HttpResponse = {
          result: cached.data,
          responseCode: 200,
          header: {},
          cookies: '',
          resultType: http.HttpDataType.STRING,
          performanceTiming: {
            dnsTiming: 0,
            tcpTiming: 0,
            tlsTiming: 0,
            firstSendTiming: 0,
            firstReceiveTiming: 0,
            totalFinishTiming: 0,
            redirectTiming: 0,
            responseHeaderTiming: 0,
            responseBodyTiming: 0,
            totalTiming: 0
          }
        };
        return mockResponse;
      } else {
        // ç¼“å­˜è¿‡æœŸï¼Œåˆ é™¤
        MusicApiService.cache.delete(url);
      }
    }

    // æ£€æŸ¥é¢‘ç‡é™åˆ¶
    await MusicApiService.checkRateLimit();

    // å‘é€è¯·æ±‚
    const httpInstance: http.HttpRequest = http.createHttp();
    try {
      const requestOptions: HttpRequestOptions = options || {
        method: http.RequestMethod.GET,
        header: {
          'Content-Type': 'application/json',
          'User-Agent': 'HarmonyOS-Music-App'
        },
        connectTimeout: 10000,
        readTimeout: 10000
      };

      const response: http.HttpResponse = await httpInstance.request(url, requestOptions);

      // ğŸ”¥ ç¼“å­˜æˆåŠŸçš„å“åº”
      if (response.responseCode === 200) {
        const resultStr: string = response.result as string;
        const cacheData: CacheData = {
          data: resultStr,
          timestamp: now
        };
        MusicApiService.cache.set(url, cacheData);
        console.info('[MusicAPI] ç»“æœå·²ç¼“å­˜');
      }

      return response;
    } finally {
      httpInstance.destroy();
    }
  }

  /**
   * è·å–éŸ³ä¹URL
   */
  static async getMusicUrl(
    source: string,
    id: string,
    quality: number = 320
  ): Promise<string> {
    console.info('[MusicAPI] è·å–éŸ³é¢‘URL');

    try {
      const url: string = `${MusicApiService.BASE_URL}?types=url&source=${source || MusicApiService.DEFAULT_SOURCE}&id=${id}&br=${quality}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const result: MusicUrlResponse = JSON.parse(response.result as string) as MusicUrlResponse;
      if (!result.url) {
        throw new Error('API è¿”å›æ— æ•ˆæ•°æ®');
      }

      return result.url;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] è·å–URLå¤±è´¥:', err.message);
      throw new Error('è·å–éŸ³é¢‘åœ°å€å¤±è´¥: ' + err.message);
    }
  }

  /**
   * æœç´¢æ­Œæ›²
   */
  static async searchSongs(
    keyword: string,
    source: string = 'netease',
    count: number = 20,
    pages: number = 1
  ): Promise<SearchResult[]> {
    try {
      const url: string = `${MusicApiService.BASE_URL}?types=search&source=${source}&name=${encodeURIComponent(keyword)}&count=${count}&pages=${pages}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const results: SearchResponse[] = JSON.parse(response.result as string) as SearchResponse[];
      const searchResults: SearchResult[] = results.map((item: SearchResponse): SearchResult => {
        return {
          id: item.id,
          name: item.name,
          artist: Array.isArray(item.artist) ? item.artist.join(', ') : item.artist,
          album: item.album,
          picId: item.pic_id,
          lyricId: item.lyric_id,
          source: item.source
        };
      });

      return searchResults;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] æœç´¢å¤±è´¥:', err.message);
      return [];
    }
  }

  /**
   * å…¼å®¹æ—§ä»£ç çš„æœç´¢æ–¹æ³•
   */
  static async searchMusic(
    keyword: string,
    source: string = 'netease'
  ): Promise<MusicItem[]> {
    const results: SearchResult[] = await MusicApiService.searchSongs(keyword, source);

    const musicItems: MusicItem[] = results.map((item: SearchResult): MusicItem => {
      return {
        id: item.id,
        name: item.name,
        artist: item.artist,
        album: item.album,
        source: item.source,
        picId: item.picId,
        lyricId: item.lyricId
      };
    });

    return musicItems;
  }

  /**
   * è·å–å°é¢ URL
   */
  static getCoverUrl(song: MusicItem): string {
    if (song.cover) {
      return song.cover;
    }
    return 'https://via.placeholder.com/300x300?text=Music';
  }

  /**
   * è·å–ä¸“è¾‘å›¾
   */
  static async getPicUrl(
    source: string,
    picId: string,
    size: number = 300
  ): Promise<string> {
    try {
      const url: string = `${MusicApiService.BASE_URL}?types=pic&source=${source}&id=${picId}&size=${size}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const result: PicResponse = JSON.parse(response.result as string) as PicResponse;
      if (!result.url) {
        throw new Error('è·å–ä¸“è¾‘å›¾å¤±è´¥');
      }

      return result.url;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] è·å–ä¸“è¾‘å›¾å¤±è´¥:', err.message);
      return '';
    }
  }

  /**
   * è·å–æ­Œè¯
   */
  static async getLyric(
    source: string,
    lyricId: string
  ): Promise<LyricResult> {
    try {
      const url: string = `${MusicApiService.BASE_URL}?types=lyric&source=${source}&id=${lyricId}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const result: LyricResponse = JSON.parse(response.result as string) as LyricResponse;
      const lyricResult: LyricResult = {
        lyric: result.lyric || '',
        tlyric: result.tlyric || ''
      };

      return lyricResult;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] è·å–æ­Œè¯å¤±è´¥:', err.message);
      const emptyResult: LyricResult = {
        lyric: '',
        tlyric: ''
      };
      return emptyResult;
    }
  }

  /**
   * å»¶è¿Ÿå‡½æ•°
   */
  private static delay(ms: number): Promise<void> {
    return new Promise<void>((resolve) => setTimeout(resolve, ms));
  }

  /**
   * ğŸ”¥ è·å–å‰©ä½™è¯·æ±‚æ¬¡æ•°
   */
  static getRemainingRequests(): number {
    const now: number = Date.now();
    MusicApiService.requestQueue = MusicApiService.requestQueue.filter(
      (timestamp: number) => now - timestamp < MusicApiService.TIME_WINDOW
    );
    return MusicApiService.MAX_REQUESTS - MusicApiService.requestQueue.length;
  }

  /**
   * ğŸ”¥ æ¸…é™¤ç¼“å­˜
   */
  static clearCache(): void {
    MusicApiService.cache.clear();
    console.info('[MusicAPI] ç¼“å­˜å·²æ¸…é™¤');
  }

  /**
   * ğŸ”¥ è·å–ç¼“å­˜ç»Ÿè®¡
   */
  static getCacheStats(): CacheStats {
    const stats: CacheStats = {
      size: MusicApiService.cache.size,
      urls: Array.from(MusicApiService.cache.keys())
    };
    return stats;
  }
}

// ğŸ”¥ æ¥å£å®šä¹‰
interface MusicUrlResponse {
  url: string;
  br: number;
  size: number;
}

interface SearchResponse {
  id: string;
  name: string;
  artist: string | string[];
  album: string;
  pic_id: string;
  url_id: string;
  lyric_id: string;
  source: string;
}

interface PicResponse {
  url: string;
}

interface LyricResponse {
  lyric: string;
  tlyric?: string;
}

export interface SearchResult {
  id: string;
  name: string;
  artist: string;
  album: string;
  picId: string;
  lyricId: string;
  source: string;
}

export interface LyricResult {
  lyric: string;
  tlyric: string;
}

export interface CacheStats {
  size: number;
  urls: string[];
}

// å¯¼å‡ºç±»å‹åˆ«å
export { LyricResult as LyricData };
export { MusicItem };

export default MusicApiService;
