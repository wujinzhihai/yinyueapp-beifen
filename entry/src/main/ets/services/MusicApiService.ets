import http from '@ohos.net.http';
import { MusicItem } from '../models/MusicModels';

// ğŸ”¥ å®šä¹‰ç¼“å­˜æ•°æ®æ¥å£
interface CacheData {
  data: string;
  timestamp: number;
  type: CacheType; // ç¼“å­˜ç±»å‹,ç”¨äºç»Ÿè®¡
}

// ğŸ”¥ å®šä¹‰ HTTP è¯·æ±‚é€‰é¡¹æ¥å£
interface HttpRequestOptions {
  method: http.RequestMethod;
  header: Record<string, string>;
  connectTimeout: number;
  readTimeout: number;
}

// ğŸ”¥ ç¼“å­˜ç±»å‹æšä¸¾
enum CacheType {
  MUSIC_URL = 'musicUrl',
  SEARCH = 'search',
  LYRIC = 'lyric',
  PIC = 'pic'
}

// ğŸ”¥ ç¼“å­˜é…ç½®æ¥å£
interface CacheConfig {
  duration: number; // è¿‡æœŸæ—¶é—´(æ¯«ç§’)
  maxSize: number;  // æœ€å¤§æ¡ç›®æ•°
}

class MusicApiService {
  private static readonly BASE_URL: string = 'https://music-api.gdstudio.xyz/api.php';
  private static readonly DEFAULT_SOURCE: string = 'netease';

  // ğŸ”¥ é™æµé…ç½®
  private static readonly MAX_REQUESTS: number = 60;
  private static readonly TIME_WINDOW: number = 5 * 60 * 1000; // 5åˆ†é’Ÿ

  private static requestQueue: number[] = [];
  private static cache: Map<string, CacheData> = new Map();

  /**
   * ğŸ”¥ è·å–ç¼“å­˜é…ç½®
   */
  private static getCacheConfig(type: CacheType): CacheConfig {
    const configs: Record<string, CacheConfig> = {
      'musicUrl': { duration: 3 * 60 * 1000, maxSize: 50 } as CacheConfig,
      'search': { duration: 30 * 60 * 1000, maxSize: 100 } as CacheConfig,
      'lyric': { duration: 60 * 60 * 1000, maxSize: 30 } as CacheConfig,
      'pic': { duration: 60 * 60 * 1000, maxSize: 50 } as CacheConfig
    };
    return configs[type as string];
  }

  /**
   * ğŸ”¥ æ£€æŸ¥å¹¶ç­‰å¾…è¯·æ±‚è®¸å¯
   */
  private static async checkRateLimit(): Promise<void> {
    const now: number = Date.now();

    // ç§»é™¤5åˆ†é’Ÿä¹‹å‰çš„è®°å½•
    MusicApiService.requestQueue = MusicApiService.requestQueue.filter(
      (timestamp: number) => now - timestamp < MusicApiService.TIME_WINDOW
    );

    // å¦‚æœè¾¾åˆ°é™åˆ¶ï¼Œç­‰å¾…
    if (MusicApiService.requestQueue.length >= MusicApiService.MAX_REQUESTS) {
      const oldestRequest: number = MusicApiService.requestQueue[0];
      const waitTime: number = MusicApiService.TIME_WINDOW - (now - oldestRequest);

      console.warn(`[MusicAPI] è¯·æ±‚é¢‘ç‡é™åˆ¶ï¼Œç­‰å¾… ${Math.ceil(waitTime/1000)} ç§’`);
      await MusicApiService.delay(waitTime);

      // é€’å½’æ£€æŸ¥
      return MusicApiService.checkRateLimit();
    }

    // è®°å½•æœ¬æ¬¡è¯·æ±‚
    MusicApiService.requestQueue.push(now);
    console.info(`[MusicAPI] è¯·æ±‚è®¡æ•°: ${MusicApiService.requestQueue.length}/${MusicApiService.MAX_REQUESTS}`);
  }

  /**
   * ğŸ”¥ ç”Ÿæˆç¼“å­˜key(å‚æ•°ç»„åˆè€Œéå®Œæ•´URL)
   */
  private static generateCacheKey(type: CacheType, params: Record<string, string>): string {
    const keys = Object.keys(params);
    keys.sort();
    const sortedParams = keys.map((key: string) => `${key}=${params[key]}`).join('&');
    return `${type as string}:${sortedParams}`;
  }

  /**
   * ğŸ”¥ æ£€æŸ¥å¹¶æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  private static cleanExpiredCache(type: CacheType): void {
    const now = Date.now();
    const config = MusicApiService.getCacheConfig(type);
    const typePrefix = `${type as string}:`;
    
    // åˆ é™¤è¿‡æœŸæ¡ç›®
    const keysToDelete: string[] = [];
    for (const key of MusicApiService.cache.keys()) {
      const value = MusicApiService.cache.get(key);
      if (value && key.startsWith(typePrefix) && now - value.timestamp > config.duration) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach((key: string) => MusicApiService.cache.delete(key));
    
    // å¦‚æœè¶…è¿‡æœ€å¤§æ¡ç›®æ•°,åˆ é™¤æœ€æ—§çš„
    const typeKeys: string[] = [];
    for (const key of MusicApiService.cache.keys()) {
      if (key.startsWith(typePrefix)) {
        typeKeys.push(key);
      }
    }
    
    if (typeKeys.length > config.maxSize) {
      interface KeyTimestamp {
        key: string;
        timestamp: number;
      }
      
      const sortedKeys: KeyTimestamp[] = [];
      typeKeys.forEach((key: string) => {
        const value = MusicApiService.cache.get(key);
        if (value) {
          sortedKeys.push({ key: key, timestamp: value.timestamp } as KeyTimestamp);
        }
      });
      
      sortedKeys.sort((a: KeyTimestamp, b: KeyTimestamp) => a.timestamp - b.timestamp);
      
      const deleteCount = sortedKeys.length - config.maxSize;
      for (let i = 0; i < deleteCount; i++) {
        MusicApiService.cache.delete(sortedKeys[i].key);
      }
      
      console.info(`[MusicAPI] æ¸…ç† ${type as string} ç¼“å­˜,åˆ é™¤ ${deleteCount} æ¡æ—§æ•°æ®`);
    }
  }

  /**
   * ğŸ”¥ HTTPè¯·æ±‚å°è£…ï¼ˆå¸¦ç¼“å­˜+é™æµï¼‰
   */
  private static async httpRequest(
    url: string,
    cacheKey: string,
    cacheType: CacheType,
    options?: HttpRequestOptions
  ): Promise<http.HttpResponse> {
    const now: number = Date.now();
    const config = MusicApiService.getCacheConfig(cacheType);

    // ğŸ”¥ æ£€æŸ¥ç¼“å­˜
    if (MusicApiService.cache.has(cacheKey)) {
      const cached: CacheData | undefined = MusicApiService.cache.get(cacheKey);
      if (cached && now - cached.timestamp < config.duration) {
        console.info('[MusicAPI] ä½¿ç”¨ç¼“å­˜ï¼Œå‰©ä½™æœ‰æ•ˆæœŸ:',
          Math.ceil((config.duration - (now - cached.timestamp)) / 1000), 'ç§’');

        // ğŸ”¥ è¿”å›æ¨¡æ‹Ÿçš„ HttpResponseï¼ˆè¡¥å…¨æ‰€æœ‰å¿…éœ€å±æ€§ï¼‰
        const mockResponse: http.HttpResponse = {
          result: cached.data,
          responseCode: 200,
          header: {},
          cookies: '',
          resultType: http.HttpDataType.STRING,
          performanceTiming: {
            dnsTiming: 0,
            tcpTiming: 0,
            tlsTiming: 0,
            firstSendTiming: 0,
            firstReceiveTiming: 0,
            totalFinishTiming: 0,
            redirectTiming: 0,
            responseHeaderTiming: 0,
            responseBodyTiming: 0,
            totalTiming: 0
          }
        };
        return mockResponse;
      }
    }
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    MusicApiService.cleanExpiredCache(cacheType);

    // æ£€æŸ¥é¢‘ç‡é™åˆ¶
    await MusicApiService.checkRateLimit();

    // å‘é€è¯·æ±‚
    const httpInstance: http.HttpRequest = http.createHttp();
    try {
      const requestOptions: HttpRequestOptions = options || {
        method: http.RequestMethod.GET,
        header: {
          'Content-Type': 'application/json',
          'User-Agent': 'HarmonyOS-Music-App'
        },
        connectTimeout: 10000,
        readTimeout: 10000
      };

      const response: http.HttpResponse = await httpInstance.request(url, requestOptions);

      // ğŸ”¥ ç¼“å­˜æˆåŠŸçš„å“åº”
      if (response.responseCode === 200) {
        const resultStr: string = response.result as string;
        const cacheData: CacheData = {
          data: resultStr,
          timestamp: now,
          type: cacheType
        };
        MusicApiService.cache.set(cacheKey, cacheData);
        console.info(`[MusicAPI] ${cacheType} ç»“æœå·²ç¼“å­˜,key: ${cacheKey.substring(0, 50)}...`);
      }

      return response;
    } finally {
      httpInstance.destroy();
    }
  }

  /**
   * è·å–éŸ³ä¹URL
   */
  static async getMusicUrl(
    source: string,
    id: string,
    quality: number = 320
  ): Promise<string> {
    console.info('[MusicAPI] è·å–éŸ³é¢‘URL');

    try {
      const params: Record<string, string> = {
        'source': source || MusicApiService.DEFAULT_SOURCE,
        'id': id,
        'br': quality.toString()
      };
      const cacheKey = MusicApiService.generateCacheKey(CacheType.MUSIC_URL, params);
      const url: string = `${MusicApiService.BASE_URL}?types=url&source=${params.source}&id=${params.id}&br=${params.br}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url, cacheKey, CacheType.MUSIC_URL);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const result: MusicUrlResponse = JSON.parse(response.result as string) as MusicUrlResponse;
      if (!result.url) {
        throw new Error('API è¿”å›æ— æ•ˆæ•°æ®');
      }

      return result.url;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] è·å–URLå¤±è´¥:', err.message);
      throw new Error('è·å–éŸ³é¢‘åœ°å€å¤±è´¥: ' + err.message);
    }
  }

  /**
   * æœç´¢æ­Œæ›²
   */
  static async searchSongs(
    keyword: string,
    source: string = 'netease',
    count: number = 20,
    pages: number = 1
  ): Promise<SearchResult[]> {
    try {
      const params: Record<string, string> = {
        'source': source,
        'keyword': keyword,
        'count': count.toString(),
        'pages': pages.toString()
      };
      const cacheKey = MusicApiService.generateCacheKey(CacheType.SEARCH, params);
      const url: string = `${MusicApiService.BASE_URL}?types=search&source=${source}&name=${encodeURIComponent(keyword)}&count=${count}&pages=${pages}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url, cacheKey, CacheType.SEARCH);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const results: SearchResponse[] = JSON.parse(response.result as string) as SearchResponse[];
      const searchResults: SearchResult[] = results.map((item: SearchResponse): SearchResult => {
        return {
          id: item.id,
          name: item.name,
          artist: Array.isArray(item.artist) ? item.artist.join(', ') : item.artist,
          album: item.album,
          picId: item.pic_id,
          lyricId: item.lyric_id,
          source: item.source
        };
      });

      return searchResults;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] æœç´¢å¤±è´¥:', err.message);
      return [];
    }
  }

  /**
   * å…¼å®¹æ—§ä»£ç çš„æœç´¢æ–¹æ³•
   */
  static async searchMusic(
    keyword: string,
    source: string = 'netease'
  ): Promise<MusicItem[]> {
    const results: SearchResult[] = await MusicApiService.searchSongs(keyword, source);

    const musicItems: MusicItem[] = results.map((item: SearchResult): MusicItem => {
      return {
        id: item.id,
        name: item.name,
        artist: item.artist,
        album: item.album,
        source: item.source,
        picId: item.picId,
        lyricId: item.lyricId
      };
    });

    return musicItems;
  }

  /**
   * è·å–å°é¢ URL
   */
  static getCoverUrl(song: MusicItem): string {
    if (song.cover) {
      return song.cover;
    }
    return 'https://via.placeholder.com/300x300?text=Music';
  }

  /**
   * è·å–ä¸“è¾‘å›¾
   */
  static async getPicUrl(
    source: string,
    picId: string,
    size: number = 300
  ): Promise<string> {
    try {
      const params: Record<string, string> = {
        'source': source,
        'id': picId,
        'size': size.toString()
      };
      const cacheKey = MusicApiService.generateCacheKey(CacheType.PIC, params);
      const url: string = `${MusicApiService.BASE_URL}?types=pic&source=${source}&id=${picId}&size=${size}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url, cacheKey, CacheType.PIC);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const result: PicResponse = JSON.parse(response.result as string) as PicResponse;
      if (!result.url) {
        throw new Error('è·å–ä¸“è¾‘å›¾å¤±è´¥');
      }

      return result.url;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] è·å–ä¸“è¾‘å›¾å¤±è´¥:', err.message);
      return '';
    }
  }

  /**
   * è·å–æ­Œè¯
   */
  static async getLyric(
    source: string,
    lyricId: string
  ): Promise<LyricResult> {
    try {
      const params: Record<string, string> = {
        'source': source,
        'id': lyricId
      };
      const cacheKey = MusicApiService.generateCacheKey(CacheType.LYRIC, params);
      const url: string = `${MusicApiService.BASE_URL}?types=lyric&source=${source}&id=${lyricId}`;
      const response: http.HttpResponse = await MusicApiService.httpRequest(url, cacheKey, CacheType.LYRIC);

      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}`);
      }

      const result: LyricResponse = JSON.parse(response.result as string) as LyricResponse;
      const lyricResult: LyricResult = {
        lyric: result.lyric || '',
        tlyric: result.tlyric || ''
      };

      return lyricResult;
    } catch (error) {
      const err = error as Error;
      console.error('[MusicAPI] è·å–æ­Œè¯å¤±è´¥:', err.message);
      const emptyResult: LyricResult = {
        lyric: '',
        tlyric: ''
      };
      return emptyResult;
    }
  }

  /**
   * å»¶è¿Ÿå‡½æ•°
   */
  private static delay(ms: number): Promise<void> {
    return new Promise<void>((resolve) => setTimeout(resolve, ms));
  }

  /**
   * ğŸ”¥ è·å–å‰©ä½™è¯·æ±‚æ¬¡æ•°
   */
  static getRemainingRequests(): number {
    const now: number = Date.now();
    MusicApiService.requestQueue = MusicApiService.requestQueue.filter(
      (timestamp: number) => now - timestamp < MusicApiService.TIME_WINDOW
    );
    return MusicApiService.MAX_REQUESTS - MusicApiService.requestQueue.length;
  }

  /**
   * ğŸ”¥ æ¸…é™¤ç¼“å­˜
   */
  static clearCache(): void {
    MusicApiService.cache.clear();
    console.info('[MusicAPI] ç¼“å­˜å·²æ¸…é™¤');
  }

  /**
   * ğŸ”¥ è·å–ç¼“å­˜ç»Ÿè®¡
   */
  static getCacheStats(): CacheStats {
    const typeStats: Record<string, number> = {};
    
    for (const key of MusicApiService.cache.keys()) {
      const value = MusicApiService.cache.get(key);
      if (value) {
        const type = value.type as string;
        if (typeStats[type]) {
          typeStats[type] = typeStats[type] + 1;
        } else {
          typeStats[type] = 1;
        }
      }
    }
    
    const urlArray: string[] = [];
    for (const key of MusicApiService.cache.keys()) {
      urlArray.push(key);
    }
    
    const stats: CacheStats = {
      size: MusicApiService.cache.size,
      urls: urlArray,
      byType: typeStats
    };
    return stats;
  }
}

// ğŸ”¥ æ¥å£å®šä¹‰
interface MusicUrlResponse {
  url: string;
  br: number;
  size: number;
}

interface SearchResponse {
  id: string;
  name: string;
  artist: string | string[];
  album: string;
  pic_id: string;
  url_id: string;
  lyric_id: string;
  source: string;
}

interface PicResponse {
  url: string;
}

interface LyricResponse {
  lyric: string;
  tlyric?: string;
}

export interface SearchResult {
  id: string;
  name: string;
  artist: string;
  album: string;
  picId: string;
  lyricId: string;
  source: string;
}

export interface LyricResult {
  lyric: string;
  tlyric: string;
}

export interface CacheStats {
  size: number;
  urls: string[];
  byType?: Record<string, number>; // æŒ‰ç±»å‹ç»Ÿè®¡
}

// å¯¼å‡ºç±»å‹åˆ«å
export { LyricResult as LyricData };
export { MusicItem };

export default MusicApiService;
