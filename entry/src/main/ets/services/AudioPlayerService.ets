import media from '@ohos.multimedia.media';
import MusicApiService from './MusicApiService';
import { MusicItem, PlayState, PlayMode } from '../models/MusicModels';

export { PlayState, PlayMode };

interface PlayerState {
  currentSong: MusicItem | null;
  playState: PlayState;
  currentTime: number;
  duration: number;
  playlist: MusicItem[];
  currentIndex: number;
  playMode: PlayMode;
}

type StateListener = (state: PlayerState) => void;

class AudioPlayerService {
  private static instance: AudioPlayerService | null = null;
  private avPlayer: media.AVPlayer | null = null;
  private state: PlayerState = {
    currentSong: null,
    playState: PlayState.IDLE,
    currentTime: 0,
    duration: 0,
    playlist: [],
    currentIndex: -1,
    playMode: PlayMode.LOOP
  };
  private listeners: StateListener[] = [];
  private updateTimer: number = -1;
  private quality: number = 320;

  private constructor() {}

  static getInstance(): AudioPlayerService {
    if (!AudioPlayerService.instance) {
      AudioPlayerService.instance = new AudioPlayerService();
    }
    return AudioPlayerService.instance;
  }

  subscribe(listener: StateListener): void {
    this.listeners.push(listener);
    listener(this.state);
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.state));
  }

  /**
   * ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šæ’­æ”¾æ­Œæ›²
   */
  async play(song: MusicItem, playlist: MusicItem[], index: number): Promise<void> {
    console.info('[AudioPlayer] å¼€å§‹æ’­æ”¾:', song.name);

    this.state.playlist = playlist;
    this.state.currentIndex = index;
    this.state.currentSong = song;
    this.state.playState = PlayState.LOADING;
    this.notifyListeners();

    try {
      const url = await MusicApiService.getMusicUrl(song.source, song.id, this.quality);
      console.info('[AudioPlayer] è·å–éŸ³é¢‘URLæˆåŠŸ');

      await this.initPlayer(url);

      this.state.playState = PlayState.PLAYING;
      this.notifyListeners();

    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      console.error('[AudioPlayer] æ’­æ”¾å¤±è´¥:', error.message);
      this.state.playState = PlayState.ERROR;
      this.notifyListeners();
      throw error;
    }
  }

  /**
   * ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šåˆå§‹åŒ–æ’­æ”¾å™¨ï¼ˆç­‰å¾…çŠ¶æ€æœºå®Œæˆï¼‰
   */
  private async initPlayer(url: string): Promise<void> {
    // é‡Šæ”¾æ—§æ’­æ”¾å™¨
    if (this.avPlayer) {
      await this.avPlayer.release();
      this.avPlayer = null;
    }

    // åˆ›å»ºæ–°æ’­æ”¾å™¨
    this.avPlayer = await media.createAVPlayer();

    // ğŸ”¥ å…³é”®ï¼šä½¿ç”¨Promiseç­‰å¾…çŠ¶æ€å˜åŒ–
    return new Promise((resolve, reject) => {
      let isPrepared = false;

      // ç›‘å¬çŠ¶æ€å˜åŒ–
      this.avPlayer!.on('stateChange', async (state) => {
        console.info('[AudioPlayer] çŠ¶æ€å˜åŒ–:', state);

        try {
          switch (state) {
            case 'initialized':
              // çŠ¶æ€2ï¼šå·²åˆå§‹åŒ–ï¼Œè°ƒç”¨prepare
              console.info('[AudioPlayer] è°ƒç”¨ prepare()');
              await this.avPlayer!.prepare();
              break;

            case 'prepared':
              // çŠ¶æ€3ï¼šå‡†å¤‡å®Œæˆï¼Œå¯ä»¥æ’­æ”¾
              console.info('[AudioPlayer] è°ƒç”¨ play()');
              isPrepared = true;
              await this.avPlayer!.play();
              this.startUpdateTimer();
              resolve(); // âœ… æˆåŠŸ
              break;

            case 'playing':
              console.info('[AudioPlayer] æ­£åœ¨æ’­æ”¾');
              break;

            case 'error':
              if (!isPrepared) {
                reject(new Error('æ’­æ”¾å™¨è¿›å…¥é”™è¯¯çŠ¶æ€'));
              }
              break;
          }
        } catch (error) {
          console.error('[AudioPlayer] çŠ¶æ€å¤„ç†å¤±è´¥:', error);
          if (!isPrepared) {
            reject(error);
          }
        }
      });

      // ç›‘å¬æ—¶é•¿æ›´æ–°
      this.avPlayer!.on('durationUpdate', (duration) => {
        this.state.duration = duration / 1000;
        this.notifyListeners();
      });

      // ç›‘å¬æ—¶é—´æ›´æ–°
      this.avPlayer!.on('timeUpdate', (time) => {
        this.state.currentTime = time / 1000;
        this.notifyListeners();
      });

      // ç›‘å¬æ’­æ”¾å®Œæˆ
      this.avPlayer!.on('endOfStream', () => {
        console.info('[AudioPlayer] æ’­æ”¾å®Œæˆ');
        this.next();
      });

      // ç›‘å¬é”™è¯¯
      this.avPlayer!.on('error', (error) => {
        console.error('[AudioPlayer] é”™è¯¯:', error);
        this.state.playState = PlayState.ERROR;
        this.notifyListeners();
        if (!isPrepared) {
          reject(error);
        }
      });

      // è®¾ç½®URLï¼ˆè§¦å‘çŠ¶æ€æœºï¼šidle â†’ initializedï¼‰
      try {
        this.avPlayer!.url = url;
        console.info('[AudioPlayer] URLå·²è®¾ç½®ï¼Œç­‰å¾…åˆå§‹åŒ–');
      } catch (error) {
        reject(error);
      }

      // è¶…æ—¶ä¿æŠ¤ï¼ˆ10ç§’ï¼‰
      setTimeout(() => {
        if (!isPrepared) {
          reject(new Error('æ’­æ”¾å™¨åˆå§‹åŒ–è¶…æ—¶'));
        }
      }, 10000);
    });
  }

  /**
   * åˆ‡æ¢æ’­æ”¾/æš‚åœ
   */
  async togglePlay(): Promise<void> {
    if (!this.avPlayer) return;

    try {
      if (this.state.playState === PlayState.PLAYING) {
        await this.avPlayer.pause();
        this.state.playState = PlayState.PAUSED;
        this.stopUpdateTimer();
      } else if (this.state.playState === PlayState.PAUSED) {
        await this.avPlayer.play();
        this.state.playState = PlayState.PLAYING;
        this.startUpdateTimer();
      }
      this.notifyListeners();
    } catch (error) {
      console.error('[AudioPlayer] åˆ‡æ¢æ’­æ”¾çŠ¶æ€å¤±è´¥:', error);
    }
  }

  /**
   * ä¸Šä¸€æ›²
   */
  previous(): void {
    if (this.state.currentIndex > 0) {
      const newIndex = this.state.currentIndex - 1;
      this.play(this.state.playlist[newIndex], this.state.playlist, newIndex);
    }
  }

  /**
   * ä¸‹ä¸€æ›²
   */
  next(): void {
    if (this.state.currentIndex < this.state.playlist.length - 1) {
      const newIndex = this.state.currentIndex + 1;
      this.play(this.state.playlist[newIndex], this.state.playlist, newIndex);
    }
  }

  /**
   * è·³è½¬åˆ°æŒ‡å®šä½ç½®
   */
  async seek(time: number): Promise<void> {
    if (this.avPlayer) {
      try {
        await this.avPlayer.seek(time * 1000);
        this.state.currentTime = time;
        this.notifyListeners();
      } catch (error) {
        console.error('[AudioPlayer] Seekå¤±è´¥:', error);
      }
    }
  }

  /**
   * è®¾ç½®éŸ³è´¨
   */
  setQuality(quality: number): void {
    this.quality = quality;
  }

  /**
   * å¯åŠ¨æ›´æ–°å®šæ—¶å™¨
   */
  private startUpdateTimer(): void {
    this.stopUpdateTimer();
    this.updateTimer = setInterval(() => {
      if (this.avPlayer && this.state.playState === PlayState.PLAYING) {
        this.notifyListeners();
      }
    }, 500);
  }

  /**
   * åœæ­¢æ›´æ–°å®šæ—¶å™¨
   */
  private stopUpdateTimer(): void {
    if (this.updateTimer !== -1) {
      clearInterval(this.updateTimer);
      this.updateTimer = -1;
    }
  }

  /**
   * é‡Šæ”¾èµ„æº
   */
  /**
   * ğŸ”¥ ä¿®å¤ï¼šåº”ç”¨å…³é—­æ—¶é‡Šæ”¾èµ„æº
   */
  async release(): Promise<void> {
    console.info('[AudioPlayer] é‡Šæ”¾èµ„æº');

    this.stopUpdateTimer();

    if (this.avPlayer) {
      try {
        // å…ˆåœæ­¢æ’­æ”¾
        if (this.state.playState === PlayState.PLAYING ||
          this.state.playState === PlayState.PAUSED) {
          await this.avPlayer.stop();
        }

        // é‡ç½®çŠ¶æ€
        await this.avPlayer.reset();

        // é‡Šæ”¾èµ„æº
        await this.avPlayer.release();

        console.info('[AudioPlayer] æ’­æ”¾å™¨å·²é‡Šæ”¾');
      } catch (error) {
        console.error('[AudioPlayer] é‡Šæ”¾å¤±è´¥:', error);
      } finally {
        this.avPlayer = null;
      }
    }

    // é‡ç½®çŠ¶æ€
    this.state.playState = PlayState.IDLE;
    this.state.currentSong = null;
    this.state.currentTime = 0;
    this.state.duration = 0;
    this.notifyListeners();
  }
  /**
   * ğŸ”¥ æ–°å¢ï¼šé‡ç½®æ’­æ”¾å™¨ï¼ˆç”¨äºé‡æ–°æ’­æ”¾ï¼‰
   */
  async reset(): Promise<void> {
    console.info('[AudioPlayer] é‡ç½®æ’­æ”¾å™¨');
    await this.release();
  }
}

export default AudioPlayerService;
