/**
 * ğŸµ éŸ³é¢‘æ’­æ”¾æœåŠ¡
 *
 * åŠŸèƒ½: ç®¡ç†éŸ³ä¹æ’­æ”¾çš„æ ¸å¿ƒæœåŠ¡
 * - å•ä¾‹æ¨¡å¼,å…¨å±€å”¯ä¸€æ’­æ”¾å™¨å®ä¾‹
 * - æ’­æ”¾/æš‚åœ/ä¸Šä¸€æ›²/ä¸‹ä¸€æ›²æ§åˆ¶
 * - æ’­æ”¾å¤±è´¥è‡ªåŠ¨é‡è¯•å’Œè·³è¿‡
 * - çŠ¶æ€ç®¡ç†å’ŒAppStorageåŒæ­¥
 * - è®¢é˜…/å–æ¶ˆè®¢é˜…æœºåˆ¶
 * - AVSessionåª’ä½“ä¼šè¯æ”¯æŒ
 * - é€šçŸ¥æ éŸ³ä¹æ§åˆ¶
 * - åå°æ’­æ”¾æ”¯æŒ
 */

import media from '@ohos.multimedia.media';
import avSession from '@ohos.multimedia.avsession';
import image from '@ohos.multimedia.image';
import MusicApiService from './MusicApiService';
import { MusicItem, PlayState, PlayMode } from '../models/MusicModels';
import { BusinessError } from '@ohos.base';

export { PlayState, PlayMode };

interface PlayerState {
  currentSong: MusicItem | null;
  playState: PlayState;
  currentTime: number;
  duration: number;
  playlist: MusicItem[];
  currentIndex: number;
  playMode: PlayMode;
}

type StateListener = (state: PlayerState) => void;

class AudioPlayerService {
  private static instance: AudioPlayerService | null = null;
  private avPlayer: media.AVPlayer | null = null;
  private session: avSession.AVSession | null = null; // ğŸµ åª’ä½“ä¼šè¯
  private state: PlayerState = {
    currentSong: null,
    playState: PlayState.IDLE,
    currentTime: 0,
    duration: 0,
    playlist: [],
    currentIndex: -1,
    playMode: PlayMode.LOOP
  };
  private listeners: StateListener[] = [];
  private updateTimer: number = -1;
  private quality: number = 320;
  private isPlayingLock: boolean = false; // ğŸ”’ æ’­æ”¾é”ï¼Œé˜²æ­¢é‡å¤åˆ‡æ­Œ
  private retryCount: number = 0; // ğŸ”„ é‡è¯•è®¡æ•°å™¨
  private maxRetries: number = 1; // ğŸ”„ æœ€å¤§é‡è¯•æ¬¡æ•°

  private constructor() {
    // å»¶è¿Ÿåˆå§‹åŒ–AVSession,ç­‰å¾…contextè®¾ç½®
    setTimeout(() => {
      this.initAVSession();
    }, 500);
  }

  static getInstance(): AudioPlayerService {
    if (!AudioPlayerService.instance) {
      AudioPlayerService.instance = new AudioPlayerService();
    }
    return AudioPlayerService.instance;
  }

  subscribe(listener: StateListener): () => void {
    this.listeners.push(listener);
    listener(this.state);
    
    // ğŸ”¥ è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.unsubscribe(listener);
    };
  }

  unsubscribe(listener: StateListener): void {
    const index = this.listeners.indexOf(listener);
    if (index > -1) {
      this.listeners.splice(index, 1);
      console.info('[AudioPlayer] ç§»é™¤ç›‘å¬å™¨,å‰©ä½™:', this.listeners.length);
    }
  }

  private notifyListeners(): void {
    console.info('ğŸ” [AudioPlayer-Debug] é€šçŸ¥ç›‘å¬å™¨ï¼Œç›‘å¬å™¨æ•°é‡:', this.listeners.length);
    console.info('ğŸ” [AudioPlayer-Debug] å½“å‰çŠ¶æ€ - æ­Œæ›²:', this.state.currentSong?.name || 'null');
    console.info('ğŸ” [AudioPlayer-Debug] å½“å‰çŠ¶æ€ - playState:', this.state.playState);
    console.info('ğŸ” [AudioPlayer-Debug] å½“å‰çŠ¶æ€ - currentIndex:', this.state.currentIndex);
    
    // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šç›´æ¥æ›´æ–° AppStorageï¼Œç¡®ä¿UIç»„ä»¶å“åº”çŠ¶æ€å˜åŒ–
    AppStorage.setOrCreate('currentSong', this.state.currentSong);
    AppStorage.setOrCreate('playState', this.state.playState);
    AppStorage.setOrCreate('currentTime', this.state.currentTime);
    AppStorage.setOrCreate('duration', this.state.duration);
    AppStorage.setOrCreate('playlist', this.state.playlist);
    AppStorage.setOrCreate('currentIndex', this.state.currentIndex);
    AppStorage.setOrCreate('playMode', this.state.playMode);
    
    console.info('âœ… [AudioPlayer-Debug] AppStorage å·²æ›´æ–°');
    
    this.listeners.forEach((listener, index) => {
      console.info(`ğŸ” [AudioPlayer-Debug] è°ƒç”¨ç›‘å¬å™¨ ${index + 1}`);
      listener(this.state);
    });
  }

  /**
   * ğŸµ åˆå§‹åŒ–AVSessionåª’ä½“ä¼šè¯
   */
  private async initAVSession(): Promise<void> {
    try {
      // ä»AppStorageè·å–ä¸Šä¸‹æ–‡
      const context = AppStorage.get('abilityContext') as Context;
      if (!context) {
        console.error('[AVSession] æ— æ³•è·å–abilityContext,å»¶è¿Ÿé‡è¯•');
        // å»¶è¿Ÿé‡è¯•
        setTimeout(() => {
          this.initAVSession();
        }, 1000);
        return;
      }

      // åˆ›å»ºåª’ä½“ä¼šè¯
      this.session = await avSession.createAVSession(
        context,
        'MusicPlayer',
        'audio'
      );
      
      console.info('[AVSession] åª’ä½“ä¼šè¯åˆ›å»ºæˆåŠŸ');

      // æ¿€æ´»ä¼šè¯
      await this.session.activate();
      console.info('[AVSession] åª’ä½“ä¼šè¯å·²æ¿€æ´»');

      // ç›‘å¬æ’­æ”¾æ§åˆ¶å‘½ä»¤
      this.session.on('play', () => {
        console.info('[AVSession] æ”¶åˆ°æ’­æ”¾å‘½ä»¤');
        this.togglePlay();
      });

      this.session.on('pause', () => {
        console.info('[AVSession] æ”¶åˆ°æš‚åœå‘½ä»¤');
        this.togglePlay();
      });

      this.session.on('stop', () => {
        console.info('[AVSession] æ”¶åˆ°åœæ­¢å‘½ä»¤');
        this.togglePlay();
      });

      this.session.on('playNext', () => {
        console.info('[AVSession] æ”¶åˆ°ä¸‹ä¸€æ›²å‘½ä»¤');
        this.next();
      });

      this.session.on('playPrevious', () => {
        console.info('[AVSession] æ”¶åˆ°ä¸Šä¸€æ›²å‘½ä»¤');
        this.previous();
      });

      this.session.on('seek', (time: number) => {
        console.info('[AVSession] æ”¶åˆ°è·³è½¬å‘½ä»¤:', time);
        this.seek(time / 1000);
      });

    } catch (error) {
      const err = error as BusinessError;
      console.error('[AVSession] åˆå§‹åŒ–å¤±è´¥:', err.code, err.message);
    }
  }

  /**
   * ğŸµ æ›´æ–°åª’ä½“ä¼šè¯å…ƒæ•°æ®
   */
  private async updateAVMetadata(): Promise<void> {
    if (!this.session || !this.state.currentSong) {
      return;
    }

    try {
      const metadata: avSession.AVMetadata = {
        assetId: this.state.currentSong.id,
        title: this.state.currentSong.name,
        artist: this.state.currentSong.artist,
        album: this.state.currentSong.album || 'æœªçŸ¥ä¸“è¾‘',
        duration: this.state.duration * 1000,
      };

      // å¦‚æœæœ‰å°é¢å›¾ç‰‡,æ·»åŠ å°é¢
      if (this.state.currentSong.picId && this.state.currentSong.source) {
        try {
          const coverUrl = await MusicApiService.getPicUrl(
            this.state.currentSong.source,
            this.state.currentSong.picId,
            200
          );
          
          // æ³¨æ„: HarmonyOSéœ€è¦PixelMapæ ¼å¼çš„å›¾ç‰‡
          // è¿™é‡Œç®€åŒ–å¤„ç†,å®é™…é¡¹ç›®ä¸­éœ€è¦å°†URLè½¬æ¢ä¸ºPixelMap
          metadata.mediaImage = coverUrl;
        } catch (error) {
          console.error('[AVSession] è·å–å°é¢å¤±è´¥:', error);
        }
      }

      await this.session.setAVMetadata(metadata);
      console.info('[AVSession] å…ƒæ•°æ®å·²æ›´æ–°');
    } catch (error) {
      const err = error as BusinessError;
      console.error('[AVSession] æ›´æ–°å…ƒæ•°æ®å¤±è´¥:', err.code, err.message);
    }
  }

  /**
   * ğŸµ æ›´æ–°æ’­æ”¾çŠ¶æ€
   */
  private async updateAVPlaybackState(): Promise<void> {
    if (!this.session) {
      return;
    }

    try {
      const playbackState: avSession.AVPlaybackState = {
        state: this.convertPlayState(this.state.playState),
        position: {
          elapsedTime: this.state.currentTime * 1000,
          updateTime: Date.now()
        },
        speed: this.state.playState === PlayState.PLAYING ? 1.0 : 0.0,
        loopMode: avSession.LoopMode.LOOP_MODE_SEQUENCE,
      };

      await this.session.setAVPlaybackState(playbackState);
      console.info('[AVSession] æ’­æ”¾çŠ¶æ€å·²æ›´æ–°');
    } catch (error) {
      const err = error as BusinessError;
      console.error('[AVSession] æ›´æ–°æ’­æ”¾çŠ¶æ€å¤±è´¥:', err.code, err.message);
    }
  }

  /**
   * ğŸµ è½¬æ¢æ’­æ”¾çŠ¶æ€
   */
  private convertPlayState(state: PlayState): avSession.PlaybackState {
    switch (state) {
      case PlayState.PLAYING:
        return avSession.PlaybackState.PLAYBACK_STATE_PLAY;
      case PlayState.PAUSED:
        return avSession.PlaybackState.PLAYBACK_STATE_PAUSE;
      case PlayState.LOADING:
        return avSession.PlaybackState.PLAYBACK_STATE_PREPARE;
      case PlayState.ERROR:
        return avSession.PlaybackState.PLAYBACK_STATE_ERROR;
      default:
        return avSession.PlaybackState.PLAYBACK_STATE_STOP;
    }
  }

  /**
   * ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šæ’­æ”¾æ­Œæ›²ï¼ˆå¸¦æ’­æ”¾é”ä¿æŠ¤å’Œé‡è¯•æœºåˆ¶ï¼‰
   */
  async play(song: MusicItem, playlist: MusicItem[], index: number, isRetry: boolean = false): Promise<void> {
    // ğŸ”’ æ£€æŸ¥æ’­æ”¾é”ï¼Œé˜²æ­¢é‡å¤åˆ‡æ­Œ
    if (this.isPlayingLock) {
      console.warn('[AudioPlayer] æ­£åœ¨åˆ‡æ­Œä¸­ï¼Œå¿½ç•¥é‡å¤è¯·æ±‚');
      return;
    }

    // ğŸ”„ å¦‚æœä¸æ˜¯é‡è¯•,é‡ç½®é‡è¯•è®¡æ•°å™¨
    if (!isRetry) {
      this.retryCount = 0;
    }

    console.info('[AudioPlayer] å¼€å§‹æ’­æ”¾:', song.name, isRetry ? `(é‡è¯• ${this.retryCount + 1}/${this.maxRetries})` : '');

    // ğŸ”’ ä¸Šé”
    this.isPlayingLock = true;

    try {
      this.state.playlist = playlist;
      this.state.currentIndex = index;
      this.state.currentSong = song;
      this.state.playState = PlayState.LOADING;
      this.notifyListeners();

      // ğŸ”¥ æ ¹æ®éŸ³ä¹æ¥æºè·å–æ’­æ”¾URL
      let url: string;
      if (song.source === 'local') {
        // æœ¬åœ°éŸ³ä¹ä½¿ç”¨æ–‡ä»¶è·¯å¾„
        url = `file://${song.localPath}`;
        console.info('[AudioPlayer] ä½¿ç”¨æœ¬åœ°æ–‡ä»¶:', url);
      } else {
        // ç½‘ç»œéŸ³ä¹è·å–URL
        url = await MusicApiService.getMusicUrl(song.source, song.id, this.quality);
        console.info('[AudioPlayer] è·å–ç½‘ç»œéŸ³é¢‘URLæˆåŠŸ');
      }

      await this.initPlayer(url);

      this.state.playState = PlayState.PLAYING;
      this.notifyListeners();
      
      // ğŸµ æ›´æ–°åª’ä½“ä¼šè¯
      await this.updateAVMetadata();
      await this.updateAVPlaybackState();
      
      // ğŸ”„ æ’­æ”¾æˆåŠŸ,é‡ç½®é‡è¯•è®¡æ•°å™¨
      this.retryCount = 0;

    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      console.error('[AudioPlayer] æ’­æ”¾å¤±è´¥:', error.message);
      this.state.playState = PlayState.ERROR;
      this.notifyListeners();
      
      // ğŸ”„ å¤„ç†æ’­æ”¾å¤±è´¥
      await this.handlePlayError(song, playlist, index);
    } finally {
      // ğŸ”“ è§£é”
      this.isPlayingLock = false;
    }
  }

  /**
   * ğŸ”„ å¤„ç†æ’­æ”¾å¤±è´¥ï¼šé‡è¯•æˆ–è·³è¿‡
   */
  private async handlePlayError(song: MusicItem, playlist: MusicItem[], index: number): Promise<void> {
    // ğŸ”„ æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡è¯•
    if (this.retryCount < this.maxRetries) {
      this.retryCount++;
      console.warn(`[AudioPlayer] æ’­æ”¾å¤±è´¥ï¼Œå‡†å¤‡é‡è¯• (${this.retryCount}/${this.maxRetries})`);
      
      // å»¶è¿Ÿ1ç§’åé‡è¯•
      await new Promise<void>((resolve: (value: void) => void) => setTimeout(resolve, 1000));
      
      try {
        await this.play(song, playlist, index, true);
      } catch (error) {
        console.error('[AudioPlayer] é‡è¯•å¤±è´¥:', error);
      }
    } else {
      // ğŸ”„ é‡è¯•æ¬¡æ•°ç”¨å®Œ,è‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€æ›²
      console.warn('[AudioPlayer] é‡è¯•æ¬¡æ•°å·²ç”¨å®Œï¼Œè‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€æ›²');
      this.retryCount = 0; // é‡ç½®è®¡æ•°å™¨
      
      // å»¶è¿Ÿ1ç§’åæ’­æ”¾ä¸‹ä¸€æ›²
      setTimeout(() => {
        this.next().catch((error: Error) => {
          console.error('[AudioPlayer] è‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€æ›²å¤±è´¥:', error);
        });
      }, 1000);
    }
  }

  /**
   * ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šåˆå§‹åŒ–æ’­æ”¾å™¨ï¼ˆç­‰å¾…çŠ¶æ€æœºå®Œæˆï¼‰
   */
  private async initPlayer(url: string): Promise<void> {
    // é‡Šæ”¾æ—§æ’­æ”¾å™¨
    if (this.avPlayer) {
      try {
        // ğŸ”¥ ä¼˜åŒ–ï¼šå…ˆç§»é™¤æ‰€æœ‰ç›‘å¬å™¨ï¼Œé¿å…æ—§å›è°ƒå¹²æ‰°
        this.avPlayer.off('stateChange');
        this.avPlayer.off('durationUpdate');
        this.avPlayer.off('timeUpdate');
        this.avPlayer.off('endOfStream');
        this.avPlayer.off('error');

        await this.avPlayer.release();
      } catch (error) {
        console.error('[AudioPlayer] é‡Šæ”¾æ—§æ’­æ”¾å™¨å¤±è´¥:', error);
      } finally {
        this.avPlayer = null;
      }
    }

    // åˆ›å»ºæ–°æ’­æ”¾å™¨
    this.avPlayer = await media.createAVPlayer();

    // ğŸ”¥ å…³é”®ï¼šä½¿ç”¨Promiseç­‰å¾…çŠ¶æ€å˜åŒ–
    return new Promise((resolve, reject) => {
      let isPrepared = false;

      // ç›‘å¬çŠ¶æ€å˜åŒ–
      this.avPlayer!.on('stateChange', async (state) => {
        console.info('[AudioPlayer] çŠ¶æ€å˜åŒ–:', state);

        try {
          switch (state) {
            case 'initialized':
              // çŠ¶æ€2ï¼šå·²åˆå§‹åŒ–ï¼Œè°ƒç”¨prepare
              console.info('[AudioPlayer] è°ƒç”¨ prepare()');
              await this.avPlayer!.prepare();
              break;

            case 'prepared':
              // çŠ¶æ€3ï¼šå‡†å¤‡å®Œæˆï¼Œå¯ä»¥æ’­æ”¾
              console.info('[AudioPlayer] è°ƒç”¨ play()');
              isPrepared = true;
              await this.avPlayer!.play();
              this.startUpdateTimer();
              resolve(); // âœ… æˆåŠŸ
              break;

            case 'playing':
              console.info('[AudioPlayer] æ­£åœ¨æ’­æ”¾');
              break;

            case 'error':
              if (!isPrepared) {
                reject(new Error('æ’­æ”¾å™¨è¿›å…¥é”™è¯¯çŠ¶æ€'));
              }
              break;
          }
        } catch (error) {
          console.error('[AudioPlayer] çŠ¶æ€å¤„ç†å¤±è´¥:', error);
          if (!isPrepared) {
            reject(error);
          }
        }
      });

      // ç›‘å¬æ—¶é•¿æ›´æ–°
      this.avPlayer!.on('durationUpdate', (duration) => {
        this.state.duration = duration / 1000;
        this.notifyListeners();
      });

      // ç›‘å¬æ—¶é—´æ›´æ–°
      this.avPlayer!.on('timeUpdate', (time) => {
        this.state.currentTime = time / 1000;
        this.notifyListeners();
      });

      // ç›‘å¬æ’­æ”¾å®Œæˆ
      this.avPlayer!.on('endOfStream', () => {
        console.info('[AudioPlayer] æ’­æ”¾å®Œæˆ');
        this.next();
      });

      // ç›‘å¬é”™è¯¯
      this.avPlayer!.on('error', (error) => {
        console.error('[AudioPlayer] é”™è¯¯:', error);
        this.state.playState = PlayState.ERROR;
        this.notifyListeners();
        if (!isPrepared) {
          reject(error);
        }
      });

      // è®¾ç½®URLï¼ˆè§¦å‘çŠ¶æ€æœºï¼šidle â†’ initializedï¼‰
      try {
        this.avPlayer!.url = url;
        console.info('[AudioPlayer] URLå·²è®¾ç½®ï¼Œç­‰å¾…åˆå§‹åŒ–');
      } catch (error) {
        reject(error);
      }

      // è¶…æ—¶ä¿æŠ¤ï¼ˆ10ç§’ï¼‰
      setTimeout(() => {
        if (!isPrepared) {
          reject(new Error('æ’­æ”¾å™¨åˆå§‹åŒ–è¶…æ—¶'));
        }
      }, 10000);
    });
  }

  /**
   * åˆ‡æ¢æ’­æ”¾/æš‚åœ
   */
  async togglePlay(): Promise<void> {
    if (!this.avPlayer) return;

    try {
      if (this.state.playState === PlayState.PLAYING) {
        await this.avPlayer.pause();
        this.state.playState = PlayState.PAUSED;
        this.stopUpdateTimer();
      } else if (this.state.playState === PlayState.PAUSED) {
        await this.avPlayer.play();
        this.state.playState = PlayState.PLAYING;
        this.startUpdateTimer();
      }
      this.notifyListeners();
      
      // ğŸµ æ›´æ–°æ’­æ”¾çŠ¶æ€
      await this.updateAVPlaybackState();
    } catch (error) {
      console.error('[AudioPlayer] åˆ‡æ¢æ’­æ”¾çŠ¶æ€å¤±è´¥:', error);
    }
  }

  /**
   * ä¸Šä¸€æ›²ï¼ˆå¼‚æ­¥æ–¹æ³•ï¼Œç­‰å¾…åˆ‡æ­Œå®Œæˆï¼‰
   */
  async previous(): Promise<void> {
    if (this.state.currentIndex > 0) {
      const newIndex = this.state.currentIndex - 1;
      await this.play(this.state.playlist[newIndex], this.state.playlist, newIndex);
    } else {
      console.warn('[AudioPlayer] å·²ç»æ˜¯ç¬¬ä¸€é¦–æ­Œ');
    }
  }

  /**
   * ä¸‹ä¸€æ›²ï¼ˆå¼‚æ­¥æ–¹æ³•ï¼Œç­‰å¾…åˆ‡æ­Œå®Œæˆï¼‰
   */
  async next(): Promise<void> {
    if (this.state.currentIndex < this.state.playlist.length - 1) {
      const newIndex = this.state.currentIndex + 1;
      await this.play(this.state.playlist[newIndex], this.state.playlist, newIndex);
    } else {
      console.warn('[AudioPlayer] å·²ç»æ˜¯æœ€åä¸€é¦–æ­Œ');
    }
  }

  /**
   * è·³è½¬åˆ°æŒ‡å®šä½ç½®
   */
  async seek(time: number): Promise<void> {
    if (this.avPlayer) {
      try {
        await this.avPlayer.seek(time * 1000);
        this.state.currentTime = time;
        this.notifyListeners();
      } catch (error) {
        console.error('[AudioPlayer] Seekå¤±è´¥:', error);
      }
    }
  }

  /**
   * è®¾ç½®éŸ³è´¨
   */
  setQuality(quality: number): void {
    this.quality = quality;
  }

  /**
   * å¯åŠ¨æ›´æ–°å®šæ—¶å™¨
   */
  private startUpdateTimer(): void {
    this.stopUpdateTimer();
    this.updateTimer = setInterval(() => {
      if (this.avPlayer && this.state.playState === PlayState.PLAYING) {
        this.notifyListeners();
      }
    }, 500);
  }

  /**
   * åœæ­¢æ›´æ–°å®šæ—¶å™¨
   */
  private stopUpdateTimer(): void {
    if (this.updateTimer !== -1) {
      clearInterval(this.updateTimer);
      this.updateTimer = -1;
    }
  }

  /**
   * ğŸ”¥ ä¿®å¤ï¼šåº”ç”¨å…³é—­æ—¶é‡Šæ”¾èµ„æº
   */
  async release(): Promise<void> {
    console.info('[AudioPlayer] é‡Šæ”¾èµ„æº');

    this.stopUpdateTimer();

    // é‡Šæ”¾åª’ä½“ä¼šè¯
    if (this.session) {
      try {
        await this.session.deactivate();
        await this.session.destroy();
        console.info('[AVSession] åª’ä½“ä¼šè¯å·²é‡Šæ”¾');
      } catch (error) {
        console.error('[AVSession] é‡Šæ”¾åª’ä½“ä¼šè¯å¤±è´¥:', error);
      } finally {
        this.session = null;
      }
    }

    if (this.avPlayer) {
      try {
        // å…ˆåœæ­¢æ’­æ”¾
        if (this.state.playState === PlayState.PLAYING ||
          this.state.playState === PlayState.PAUSED) {
          await this.avPlayer.stop();
        }

        // é‡ç½®çŠ¶æ€
        await this.avPlayer.reset();

        // é‡Šæ”¾èµ„æº
        await this.avPlayer.release();

        console.info('[AudioPlayer] æ’­æ”¾å™¨å·²é‡Šæ”¾');
      } catch (error) {
        console.error('[AudioPlayer] é‡Šæ”¾å¤±è´¥:', error);
      } finally {
        this.avPlayer = null;
      }
    }

    // é‡ç½®çŠ¶æ€
    this.state.playState = PlayState.IDLE;
    this.state.currentSong = null;
    this.state.currentTime = 0;
    this.state.duration = 0;
    this.notifyListeners();
  }

  /**
   * ğŸ”¥ æ–°å¢ï¼šé‡ç½®æ’­æ”¾å™¨ï¼ˆç”¨äºé‡æ–°æ’­æ”¾ï¼‰
   */
  async reset(): Promise<void> {
    console.info('[AudioPlayer] é‡ç½®æ’­æ”¾å™¨');
    await this.release();
  }
}

export default AudioPlayerService;
