/**
 * ğŸ“ æœ¬åœ°éŸ³ä¹æœåŠ¡
 *
 * åŠŸèƒ½: æ‰«æå’Œç®¡ç†æœ¬åœ°éŸ³ä¹æ–‡ä»¶
 * - æ‰«ææœ¬åœ°éŸ³ä¹ç›®å½•
 * - è§£æéŸ³é¢‘æ–‡ä»¶ä¿¡æ¯
 * - æä¾›æœ¬åœ°éŸ³ä¹æœç´¢
 * - ç®¡ç†æœ¬åœ°éŸ³ä¹åˆ—è¡¨
 */

import fileIo from '@ohos.file.fs';
import { MusicItem } from '../models/MusicModels';

export class LocalMusicService {
  private static localMusicList: MusicItem[] = [];
  private static isScanned: boolean = false;

  /**
   * æ‰«ææœ¬åœ°éŸ³ä¹
   * @returns æœ¬åœ°éŸ³ä¹åˆ—è¡¨
   */
  static async scanLocalMusic(): Promise<MusicItem[]> {
    if (LocalMusicService.isScanned) {
      return LocalMusicService.localMusicList;
    }

    try {
      console.info('[LocalMusic] å¼€å§‹æ‰«ææœ¬åœ°éŸ³ä¹...');

      // æ‰«æéŸ³ä¹ç›®å½•
      const musicPaths = [
        '/storage/media/100/local/files/Music',
        '/storage/media/100/local/files/Download'
      ];

      LocalMusicService.localMusicList = [];

      for (const path of musicPaths) {
        try {
          const files = await LocalMusicService.scanDirectory(path);
          LocalMusicService.localMusicList.push(...files);
        } catch (error) {
          console.warn('[LocalMusic] è·³è¿‡ç›®å½•:', path);
        }
      }

      LocalMusicService.isScanned = true;
      console.info('[LocalMusic] æ‰«æå®Œæˆ,å…±', LocalMusicService.localMusicList.length, 'é¦–');

      return LocalMusicService.localMusicList;
    } catch (error) {
      console.error('[LocalMusic] æ‰«æå¤±è´¥:', error);
      return [];
    }
  }

  /**
   * æ‰«ææŒ‡å®šç›®å½•
   * @param path ç›®å½•è·¯å¾„
   * @returns éŸ³ä¹æ–‡ä»¶åˆ—è¡¨
   */
  private static async scanDirectory(path: string): Promise<MusicItem[]> {
    const musicList: MusicItem[] = [];

    try {
      const files = fileIo.listFileSync(path);

      for (const file of files) {
        const fullPath = `${path}/${file}`;

        if (LocalMusicService.isAudioFile(file)) {
          const musicItem = LocalMusicService.createMusicItem(fullPath, file);
          musicList.push(musicItem);
        }
      }
    } catch (error) {
      console.error('[LocalMusic] æ‰«æç›®å½•å¤±è´¥:', path, error);
    }

    return musicList;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºéŸ³é¢‘æ–‡ä»¶
   * @param filename æ–‡ä»¶å
   * @returns æ˜¯å¦ä¸ºéŸ³é¢‘æ–‡ä»¶
   */
  private static isAudioFile(filename: string): boolean {
    const audioExtensions = ['.mp3', '.flac', '.wav', '.m4a', '.aac', '.ogg'];
    return audioExtensions.some(ext => filename.toLowerCase().endsWith(ext));
  }

  /**
   * åˆ›å»ºéŸ³ä¹é¡¹
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @param filename æ–‡ä»¶å
   * @returns éŸ³ä¹é¡¹
   */
  private static createMusicItem(filePath: string, filename: string): MusicItem {
    // å»é™¤æ–‡ä»¶æ‰©å±•å
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');

    // å°è¯•ä»æ–‡ä»¶åè§£ææ­Œæ‰‹å’Œæ­Œå (æ ¼å¼: æ­Œæ‰‹ - æ­Œå)
    let name = nameWithoutExt;
    let artist = 'æœªçŸ¥è‰ºæœ¯å®¶';

    if (nameWithoutExt.includes(' - ')) {
      const parts = nameWithoutExt.split(' - ');
      artist = parts[0].trim();
      name = parts[1].trim();
    }

    const musicItem: MusicItem = {
      id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: name,
      artist: artist,
      album: 'æœ¬åœ°éŸ³ä¹',
      source: 'local',
      localPath: filePath,
      duration: 0
    };
    
    return musicItem;
  }

  /**
   * æœç´¢æœ¬åœ°éŸ³ä¹
   * @param keyword æœç´¢å…³é”®è¯
   * @returns åŒ¹é…çš„éŸ³ä¹åˆ—è¡¨
   */
  static searchLocalMusic(keyword: string): MusicItem[] {
    const lowerKeyword = keyword.toLowerCase();
    return LocalMusicService.localMusicList.filter(song =>
      song.name.toLowerCase().includes(lowerKeyword) ||
      song.artist.toLowerCase().includes(lowerKeyword)
    );
  }

  /**
   * è·å–æ‰€æœ‰æœ¬åœ°éŸ³ä¹
   * @returns æœ¬åœ°éŸ³ä¹åˆ—è¡¨
   */
  static getLocalMusicList(): MusicItem[] {
    return LocalMusicService.localMusicList;
  }

  /**
   * åˆ·æ–°æœ¬åœ°éŸ³ä¹åº“
   * @returns æ›´æ–°åçš„éŸ³ä¹åˆ—è¡¨
   */
  static async refresh(): Promise<MusicItem[]> {
    LocalMusicService.isScanned = false;
    LocalMusicService.localMusicList = [];
    return await LocalMusicService.scanLocalMusic();
  }

  /**
   * è·å–æœ¬åœ°éŸ³ä¹æ•°é‡
   * @returns éŸ³ä¹æ•°é‡
   */
  static getCount(): number {
    return LocalMusicService.localMusicList.length;
  }

  /**
   * ä»åº”ç”¨åˆ—è¡¨ä¸­ç§»é™¤éŸ³ä¹(ä¸åˆ é™¤æ‰‹æœºæ–‡ä»¶)
   * @param musicId éŸ³ä¹ID
   * @returns æ˜¯å¦æˆåŠŸ
   */
  static removeFromList(musicId: string): boolean {
    const index = LocalMusicService.localMusicList.findIndex(item => item.id === musicId);
    if (index > -1) {
      LocalMusicService.localMusicList.splice(index, 1);
      console.info('[LocalMusic] å·²ä»åˆ—è¡¨ç§»é™¤:', musicId);
      return true;
    }
    return false;
  }

  /**
   * æ‰¹é‡ä»åº”ç”¨åˆ—è¡¨ä¸­ç§»é™¤éŸ³ä¹
   * @param musicIds éŸ³ä¹IDæ•°ç»„
   * @returns ç§»é™¤çš„æ•°é‡
   */
  static removeBatchFromList(musicIds: string[]): number {
    let count = 0;
    for (const id of musicIds) {
      if (LocalMusicService.removeFromList(id)) {
        count++;
      }
    }
    console.info('[LocalMusic] æ‰¹é‡ç§»é™¤å®Œæˆ,å…±', count, 'é¦–');
    return count;
  }

  /**
   * æ¸…ç©ºåº”ç”¨éŸ³ä¹åˆ—è¡¨(ä¸åˆ é™¤æ‰‹æœºæ–‡ä»¶)
   */
  static clearList(): void {
    LocalMusicService.localMusicList = [];
    console.info('[LocalMusic] å·²æ¸…ç©ºåˆ—è¡¨');
  }
}